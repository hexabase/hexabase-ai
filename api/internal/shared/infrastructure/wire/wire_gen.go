// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package wire

import (
	"database/sql"
	"github.com/ClickHouse/clickhouse-go/v2"
	"github.com/google/wire"
	"github.com/hexabase/hexabase-ai/api/internal/api/handlers"
	"github.com/hexabase/hexabase-ai/api/internal/application/domain"
	"github.com/hexabase/hexabase-ai/api/internal/application/handler"
	"github.com/hexabase/hexabase-ai/api/internal/application/repository"
	"github.com/hexabase/hexabase-ai/api/internal/application/service"
	domain3 "github.com/hexabase/hexabase-ai/api/internal/auth/domain"
	handler2 "github.com/hexabase/hexabase-ai/api/internal/auth/handler"
	repository2 "github.com/hexabase/hexabase-ai/api/internal/auth/repository"
	service2 "github.com/hexabase/hexabase-ai/api/internal/auth/service"
	aiops3 "github.com/hexabase/hexabase-ai/api/internal/domain/aiops"
	backup2 "github.com/hexabase/hexabase-ai/api/internal/domain/backup"
	billing3 "github.com/hexabase/hexabase-ai/api/internal/domain/billing"
	cicd3 "github.com/hexabase/hexabase-ai/api/internal/domain/cicd"
	function3 "github.com/hexabase/hexabase-ai/api/internal/domain/function"
	logs3 "github.com/hexabase/hexabase-ai/api/internal/domain/logs"
	monitoring3 "github.com/hexabase/hexabase-ai/api/internal/domain/monitoring"
	node3 "github.com/hexabase/hexabase-ai/api/internal/domain/node"
	"github.com/hexabase/hexabase-ai/api/internal/helm"
	handler3 "github.com/hexabase/hexabase-ai/api/internal/organization/handler"
	repository4 "github.com/hexabase/hexabase-ai/api/internal/organization/repository"
	service3 "github.com/hexabase/hexabase-ai/api/internal/organization/service"
	domain4 "github.com/hexabase/hexabase-ai/api/internal/project/domain"
	handler4 "github.com/hexabase/hexabase-ai/api/internal/project/handler"
	repository5 "github.com/hexabase/hexabase-ai/api/internal/project/repository"
	service4 "github.com/hexabase/hexabase-ai/api/internal/project/service"
	"github.com/hexabase/hexabase-ai/api/internal/repository/aiops"
	"github.com/hexabase/hexabase-ai/api/internal/repository/backup"
	"github.com/hexabase/hexabase-ai/api/internal/repository/billing"
	"github.com/hexabase/hexabase-ai/api/internal/repository/cicd"
	"github.com/hexabase/hexabase-ai/api/internal/repository/function"
	kubernetes2 "github.com/hexabase/hexabase-ai/api/internal/repository/kubernetes"
	"github.com/hexabase/hexabase-ai/api/internal/repository/logs"
	"github.com/hexabase/hexabase-ai/api/internal/repository/monitoring"
	"github.com/hexabase/hexabase-ai/api/internal/repository/node"
	"github.com/hexabase/hexabase-ai/api/internal/repository/proxmox"
	aiops2 "github.com/hexabase/hexabase-ai/api/internal/service/aiops"
	backup3 "github.com/hexabase/hexabase-ai/api/internal/service/backup"
	billing2 "github.com/hexabase/hexabase-ai/api/internal/service/billing"
	cicd2 "github.com/hexabase/hexabase-ai/api/internal/service/cicd"
	function2 "github.com/hexabase/hexabase-ai/api/internal/service/function"
	logs2 "github.com/hexabase/hexabase-ai/api/internal/service/logs"
	monitoring2 "github.com/hexabase/hexabase-ai/api/internal/service/monitoring"
	node2 "github.com/hexabase/hexabase-ai/api/internal/service/node"
	"github.com/hexabase/hexabase-ai/api/internal/shared/config"
	domain2 "github.com/hexabase/hexabase-ai/api/internal/workspace/domain"
	handler5 "github.com/hexabase/hexabase-ai/api/internal/workspace/handler"
	repository3 "github.com/hexabase/hexabase-ai/api/internal/workspace/repository"
	service5 "github.com/hexabase/hexabase-ai/api/internal/workspace/service"
	"gorm.io/gorm"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/metrics/pkg/client/clientset/versioned"
	"log/slog"
	"net/http"
	"time"
)

// Injectors from wire.go:

func InitializeApp(cfg *config.Config, db *gorm.DB, k8sClient kubernetes.Interface, dynamicClient dynamic.Interface, k8sConfig *rest.Config, logger *slog.Logger) (*App, error) {
	domainRepository := repository.NewPostgresRepository(db)
	versionedInterface, err := ProvideMetricsClientset(k8sConfig)
	if err != nil {
		return nil, err
	}
	kubernetesRepository := repository.NewKubernetesRepository(k8sClient, versionedInterface)
	domainService := service.NewService(domainRepository, kubernetesRepository)
	applicationHandler := handler.NewApplicationHandler(domainService)
	repository6 := repository2.NewPostgresRepository(db)
	v := ProvideOAuthProviderConfigs(cfg)
	oAuthRepository := repository2.NewOAuthRepository(v, logger)
	keyRepository, err := repository2.NewKeyRepository()
	if err != nil {
		return nil, err
	}
	service6 := service2.NewService(repository6, oAuthRepository, keyRepository, logger)
	handlerHandler := handler2.NewHandler(service6, logger)
	backupRepository := backup.NewPostgresRepository(db)
	proxmoxRepository := ProvideBackupProxmoxRepository(cfg)
	repository7 := repository3.NewPostgresRepository(db)
	backupService := ProvideBackupService(backupRepository, proxmoxRepository, domainRepository, repository7, k8sClient, cfg)
	backupHandler := handlers.NewBackupHandler(backupService)
	billingRepository := billing.NewPostgresRepository(db)
	stripeAPIKey := ProvideStripeAPIKey(cfg)
	stripeWebhookSecret := ProvideStripeWebhookSecret(cfg)
	stripeRepository := ProvideStripeRepository(stripeAPIKey, stripeWebhookSecret)
	billingService := billing2.NewService(billingRepository, stripeRepository, logger)
	billingHandler := handlers.NewBillingHandler(billingService, logger)
	monitoringRepository := monitoring.NewPostgresRepository(db)
	repository8 := kubernetes2.NewKubernetesRepository(k8sClient)
	monitoringService := monitoring2.NewService(monitoringRepository, repository8, logger)
	monitoringHandler := handlers.NewMonitoringHandler(monitoringService, logger)
	postgresRepository := node.NewPostgresRepository(db)
	nodeRepository := ProvideNodeRepository(postgresRepository)
	nodeProxmoxRepository := ProvideProxmoxRepository(cfg)
	proxmoxRepository2 := ProvideProxmoxRepositoryInterface(nodeProxmoxRepository)
	nodeService := node2.NewService(nodeRepository, proxmoxRepository2)
	service7 := ProvideNodeService(nodeService)
	nodeHandler := handlers.NewNodeHandler(service7, logger)
	repository9 := repository4.NewPostgresRepository(db)
	authRepository := repository4.NewAuthRepositoryAdapter(repository6)
	domainBillingRepository := repository4.NewBillingRepositoryAdapter(stripeRepository)
	service8 := service3.NewService(repository9, authRepository, domainBillingRepository, logger)
	handler6 := handler3.NewHandler(service8, logger)
	repository10 := repository5.NewPostgresRepository(db)
	domainKubernetesRepository := repository5.NewKubernetesRepository(k8sClient, dynamicClient, k8sConfig)
	service9 := service4.NewService(repository10, domainKubernetesRepository, logger)
	handler7 := handler4.NewHandler(service9, logger)
	kubernetesRepository2 := repository3.NewKubernetesRepository(k8sClient, dynamicClient, k8sConfig)
	domainAuthRepository := repository3.NewAuthRepositoryAdapter(repository6)
	helmService := helm.NewService(k8sConfig, logger)
	service10 := service5.NewService(repository7, kubernetesRepository2, domainAuthRepository, helmService, logger)
	handler8 := handler5.NewHandler(service10, logger)
	cicdRepository := cicd.NewPostgresRepository(db)
	cicdNamespace := ProvideCICDNamespace()
	providerFactory := ProvideCICDProviderFactory(k8sClient, k8sConfig, cicdNamespace)
	credentialManager := ProvideCICDCredentialManager(k8sClient, cicdNamespace)
	cicdService := cicd2.NewService(cicdRepository, providerFactory, credentialManager, logger)
	cicdHandler := handlers.NewCICDHandler(cicdService, logger)
	sqlDB, err := ProvideSQLDB(db)
	if err != nil {
		return nil, err
	}
	functionPostgresRepository := function.NewPostgresRepository(sqlDB)
	functionRepository := ProvideFunctionRepository(functionPostgresRepository)
	functionProviderFactory := ProvideFunctionProviderFactory(k8sClient, dynamicClient)
	functionService := function2.NewService(functionRepository, functionProviderFactory, logger)
	service11 := ProvideFunctionService(functionService)
	functionHandler := handlers.NewFunctionHandler(service11, logger)
	aiOpsProxyHandler, err := ProvideAIOpsProxyHandler(service6, logger, cfg)
	if err != nil {
		return nil, err
	}
	v2, err := ProvideClickHouseConnection(cfg)
	if err != nil {
		return nil, err
	}
	logsRepository := logs.NewClickHouseRepository(v2)
	logsService := logs2.NewLogService(logsRepository, logger)
	llmService := ProvideOllamaService(cfg)
	aiopsRepository := aiops.NewPostgresRepository(db)
	aiopsService := aiops2.NewService(llmService, aiopsRepository, logger)
	internalHandler := ProvideInternalHandler(service10, service9, domainService, service7, logsService, monitoringService, aiopsService, cicdService, backupService, logger)
	app := NewApp(applicationHandler, handlerHandler, backupHandler, billingHandler, monitoringHandler, nodeHandler, handler6, handler7, handler8, cicdHandler, functionHandler, aiOpsProxyHandler, internalHandler)
	return app, nil
}

// wire.go:

// Updated wire sets for migrated packages
var ApplicationSet = wire.NewSet(repository.NewPostgresRepository, repository.NewKubernetesRepository, service.NewService, handler.NewApplicationHandler)

var AuthSet = wire.NewSet(repository2.NewPostgresRepository, repository2.NewOAuthRepository, repository2.NewKeyRepository, service2.NewService, handler2.NewHandler)

var OrganizationSet = wire.NewSet(repository4.NewPostgresRepository, repository4.NewAuthRepositoryAdapter, repository4.NewBillingRepositoryAdapter, service3.NewService, handler3.NewHandler)

var ProjectSet = wire.NewSet(repository5.NewPostgresRepository, repository5.NewKubernetesRepository, service4.NewService, handler4.NewHandler)

var WorkspaceSet = wire.NewSet(repository3.NewPostgresRepository, repository3.NewKubernetesRepository, repository3.NewAuthRepositoryAdapter, service5.NewService, handler5.NewHandler)

// Legacy wire sets for packages that haven't been migrated yet
var BackupSet = wire.NewSet(backup.NewPostgresRepository, ProvideBackupProxmoxRepository,
	ProvideBackupService, handlers.NewBackupHandler,
)

var BillingSet = wire.NewSet(billing.NewPostgresRepository, ProvideStripeRepository, billing2.NewService, handlers.NewBillingHandler)

var MonitoringSet = wire.NewSet(monitoring.NewPostgresRepository, kubernetes2.NewKubernetesRepository, monitoring2.NewService, handlers.NewMonitoringHandler)

var NodeSet = wire.NewSet(node.NewPostgresRepository, ProvideNodeRepository,
	ProvideProxmoxRepository,
	ProvideProxmoxRepositoryInterface, node2.NewService, ProvideNodeService, handlers.NewNodeHandler,
)

var CICDSet = wire.NewSet(cicd.NewPostgresRepository, ProvideCICDProviderFactory,
	ProvideCICDCredentialManager, cicd2.NewService, handlers.NewCICDHandler,
)

var FunctionSet = wire.NewSet(
	ProvideSQLDB, function.NewPostgresRepository, ProvideFunctionRepository,
	ProvideFunctionProviderFactory, function2.NewService, ProvideFunctionService, handlers.NewFunctionHandler,
)

var HelmSet = wire.NewSet(helm.NewService)

var AIOpsProxySet = wire.NewSet(
	ProvideAIOpsProxyHandler,
)

var AIOpsSet = wire.NewSet(aiops.NewPostgresRepository, ProvideOllamaService, aiops2.NewService)

var LogSet = wire.NewSet(
	ProvideClickHouseConnection, logs.NewClickHouseRepository, logs2.NewLogService,
)

var InternalSet = wire.NewSet(ProvideInternalHandler)

type App struct {
	ApplicationHandler  *handler.ApplicationHandler
	AuthHandler         *handler2.Handler
	BackupHandler       *handlers.BackupHandler
	BillingHandler      *handlers.BillingHandler
	MonitoringHandler   *handlers.MonitoringHandler
	NodeHandler         *handlers.NodeHandler
	OrganizationHandler *handler3.Handler
	ProjectHandler      *handler4.Handler
	WorkspaceHandler    *handler5.Handler
	CICDHandler         *handlers.CICDHandler
	FunctionHandler     *handlers.FunctionHandler
	AIOpsProxyHandler   *handlers.AIOpsProxyHandler
	InternalHandler     *handlers.InternalHandler
}

func NewApp(
	appH *handler.ApplicationHandler,
	authH *handler2.Handler,
	backupH *handlers.BackupHandler,
	billH *handlers.BillingHandler,
	monH *handlers.MonitoringHandler,
	nodeH *handlers.NodeHandler,
	orgH *handler3.Handler,
	projH *handler4.Handler,
	workH *handler5.Handler,
	cicdH *handlers.CICDHandler,
	funcH *handlers.FunctionHandler,
	aiopsH *handlers.AIOpsProxyHandler,
	internalHandler *handlers.InternalHandler,
) *App {
	return &App{
		ApplicationHandler:  appH,
		AuthHandler:         authH,
		BackupHandler:       backupH,
		BillingHandler:      billH,
		MonitoringHandler:   monH,
		NodeHandler:         nodeH,
		OrganizationHandler: orgH,
		ProjectHandler:      projH,
		WorkspaceHandler:    workH,
		CICDHandler:         cicdH,
		FunctionHandler:     funcH,
		AIOpsProxyHandler:   aiopsH,
		InternalHandler:     internalHandler,
	}
}

type StripeAPIKey string

type StripeWebhookSecret string

type AIOpsServiceURL string

type CICDNamespace string

type BackupEncryptionKey string

func ProvideOAuthProviderConfigs(cfg *config.Config) map[string]*repository2.ProviderConfig {
	providers := make(map[string]*repository2.ProviderConfig)
	if cfg.Auth.ExternalProviders == nil {
		return providers
	}
	for name, p := range cfg.Auth.ExternalProviders {
		providers[name] = &repository2.ProviderConfig{
			ClientID:     p.ClientID,
			ClientSecret: p.ClientSecret,
			RedirectURL:  p.RedirectURL,
			Scopes:       p.Scopes,
			AuthURL:      p.AuthURL,
			TokenURL:     p.TokenURL,
		}
	}
	return providers
}

func ProvideStripeAPIKey(cfg *config.Config) StripeAPIKey { return StripeAPIKey(cfg.Stripe.APIKey) }

func ProvideStripeWebhookSecret(cfg *config.Config) StripeWebhookSecret {
	return StripeWebhookSecret(cfg.Stripe.WebhookSecret)
}

func ProvideAIOpsServiceURL(cfg *config.Config) (AIOpsServiceURL, error) {
	if cfg.AIOps.URL != "" {
		return AIOpsServiceURL(cfg.AIOps.URL), nil
	}
	return AIOpsServiceURL("http://ai-ops-service.ai-ops.svc.cluster.local:8000"), nil
}

func ProvideStripeRepository(apiKey StripeAPIKey, webhookSecret StripeWebhookSecret) billing3.StripeRepository {
	return billing.NewStripeRepository(string(apiKey), string(webhookSecret))
}

func ProvideCICDNamespace() CICDNamespace { return CICDNamespace("hexabase-cicd") }

func ProvideCICDProviderFactory(kubeClient kubernetes.Interface, k8sConfig *rest.Config, namespace CICDNamespace) cicd3.ProviderFactory {
	return cicd.NewProviderFactory(kubeClient, k8sConfig, string(namespace))
}

func ProvideCICDCredentialManager(kubeClient kubernetes.Interface, namespace CICDNamespace) cicd3.CredentialManager {
	return cicd.NewKubernetesCredentialManager(kubeClient, string(namespace))
}

func ProvideFunctionProviderFactory(kubeClient kubernetes.Interface, dynamicClient dynamic.Interface) function3.ProviderFactory {
	return function.NewProviderFactory(kubeClient, dynamicClient)
}

func ProvideFunctionService(service6 *function2.Service) function3.Service {
	return service6
}

func ProvideSQLDB(gormDB *gorm.DB) (*sql.DB, error) {
	return gormDB.DB()
}

func ProvideFunctionRepository(repo *function.PostgresRepository) function3.Repository {
	return repo
}

func ProvideClickHouseConnection(cfg *config.Config) (clickhouse.Conn, error) {

	conn, err := clickhouse.Open(&clickhouse.Options{
		Addr: []string{cfg.ClickHouse.Address},
	})
	if err != nil {
		return nil, err
	}
	return conn, nil
}

func ProvideProxmoxRepository(cfg *config.Config) *node.ProxmoxRepository {

	httpClient := &http.Client{
		Timeout: 30 * time.Second,
	}
	return node.NewProxmoxRepository(httpClient, "https://proxmox.example.com/api2/json", "your-api-token")
}

func ProvideMetricsClientset(k8sConfig *rest.Config) (versioned.Interface, error) {
	return versioned.NewForConfig(k8sConfig)
}

func ProvideNodeService(svc *node2.Service) node3.Service {
	return svc
}

func ProvideNodeRepository(repo *node.PostgresRepository) node3.Repository {
	return repo
}

func ProvideProxmoxRepositoryInterface(repo *node.ProxmoxRepository) node3.ProxmoxRepository {
	return repo
}

func ProvideBackupProxmoxRepository(cfg *config.Config) backup2.ProxmoxRepository {

	client := proxmox.NewClient("https://proxmox.example.com/api2/json", "root@pam", "tokenID", "tokenSecret")
	return backup.NewProxmoxRepository(client)
}

func ProvideBackupService(
	repo backup2.Repository,
	proxmoxRepo backup2.ProxmoxRepository,
	appRepo domain.Repository,
	workspaceRepo domain2.Repository,
	k8sClient kubernetes.Interface,
	cfg *config.Config,
) backup2.Service {

	encryptionKey := "your-backup-encryption-key"
	return backup3.NewService(repo, proxmoxRepo, appRepo, workspaceRepo, k8sClient, encryptionKey)
}

func ProvideAIOpsProxyHandler(authSvc domain3.Service, logger *slog.Logger, cfg *config.Config) (*handlers.AIOpsProxyHandler, error) {
	var aiopsURL string
	if cfg.AIOps.URL != "" {
		aiopsURL = cfg.AIOps.URL
	} else {
		aiopsURL = "http://ai-ops-service.ai-ops.svc.cluster.local:8000"
	}
	return handlers.NewAIOpsProxyHandler(authSvc, logger, aiopsURL)
}

func ProvideOllamaService(cfg *config.Config) aiops3.LLMService {

	ollamaURL := "http://ollama.ollama.svc.cluster.local:11434"
	timeout := 30 * time.Second
	headers := make(map[string]string)
	return aiops.NewOllamaProvider(ollamaURL, timeout, headers)
}

func ProvideInternalHandler(
	workspaceSvc domain2.Service,
	projectSvc domain4.Service,
	applicationSvc domain.Service,
	nodeSvc node3.Service,
	logSvc logs3.Service,
	monitoringSvc monitoring3.Service,
	aiopsSvc aiops3.Service,
	cicdSvc cicd3.Service,
	backupSvc backup2.Service,
	logger *slog.Logger,
) *handlers.InternalHandler {
	return handlers.NewInternalHandler(
		workspaceSvc,
		projectSvc,
		applicationSvc,
		nodeSvc,
		logSvc,
		monitoringSvc,
		aiopsSvc,
		cicdSvc,
		backupSvc,
		logger,
	)
}
