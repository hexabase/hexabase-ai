# HKS Logging and Auditing Architecture

## 1. Overview

This document defines the comprehensive logging and auditing strategy for the Hexabase KaaS (HKS) platform. The goal is to provide visibility for different stakeholders (HKS Developers, Organization Admins, Workspace Admins, Users) into system health, user activities, and application behavior, while ensuring strict security and data isolation.

We classify logs into three distinct categories based on their purpose and audience.

## 2. Log Categories and Technology Stack

| Log Category      | Description                                                                                              | Primary Audience   | Storage Technology | Visualization       | Data Retention                                    |
| :---------------- | :------------------------------------------------------------------------------------------------------- | :----------------- | :----------------- | :------------------ | :------------------------------------------------ |
| **System Logs**   | Logs generated by HKS platform components (Control Plane, AIOps, etc.) for debugging and monitoring.     | HKS SRE/Developers | **Loki**           | Grafana             | Medium-term (e.g., 30 days)                       |
| **Audit Logs**    | Immutable record of actions taken by users or by automated systems (like AIOps) on their behalf.         | HKS Admins, Users  | **ClickHouse**     | Grafana, User Pages | Long-term (e.g., 1+ years, for compliance)        |
| **Workload Logs** | Logs from user-deployed applications (`stdout`/`stderr` from pods) running within a project's namespace. | Users              | **Loki**           | Grafana             | Short/Medium-term (e.g., 7-30 days, configurable) |

## 3. Core Security Principles

### 3.1. Mandatory Log Enrichment

To enable secure, multi-tenant log filtering, all structured logs generated within the context of an authenticated API request **must** be automatically enriched with tenancy and user information. A logging middleware in the Go backend will be responsible for injecting the following fields into every log entry:

- `organization_id`
- `workspace_id` (if applicable)
- `user_id`

This enrichment is the non-negotiable foundation of the logging security model.

### 3.2. Backend-Enforced Access Control

The user interface and other clients **must not** have direct access to the underlying log storage systems (Loki, ClickHouse). All log access will be brokered through secure HKS API endpoints, which will act as a gatekeeper to enforce access policies.

## 4. System Logs

- **Source**: All HKS backend components, including the Go Control Plane, Python AIOps system, and other supporting services.
- **Collection**: Services will log `stdout`/`stderr` in a structured JSON format. A log collection agent (Promtail) will forward these logs to a central Loki instance.
- **Purpose**: To monitor the health of the HKS platform, diagnose issues, and analyze performance. These logs are primarily for internal HKS operational staff and are not exposed to tenants.

## 5. Audit Logs

Audit logs provide a "who, what, when, where" record of all significant events.

- **Source**:
  - **HKS API**: All state-changing actions.
  - **Kubernetes API Server**: Captured via an [Audit Webhook](https://kubernetes.io/docs/tasks/debug/debug-cluster/audit/#webhook-backend).
  - **AIOps System**: Actions are logged as an audit event, impersonating the user, with an additional field `initiated_by: "AIOpsAgent"`.
- **Storage**: Events are stored in a `logs.audit` table in ClickHouse. The schema will include `timestamp`, `user_id`, `organization_id`, `workspace_id`, `source_ip`, `event_type`, `resource_id`, `details_json`, etc.
- **Access Control and Visibility**:
  - **Organization Admin**: Can view all audit logs within their organization.
  - **Workspace Admin**: Can view all audit logs within their assigned workspaces.
  - **User**: Can view audit logs related to their own actions.
- **Security Implementation**:
  - The HKS API will provide endpoints like `GET /api/v1/organizations/{orgId}/logs`.
  - The API handler will extract the user's identity and roles from their JWT.
  - It will then construct a ClickHouse query, **injecting a non-negotiable `WHERE` clause** to scope the results. For example, for a Workspace Admin, the query will always include `AND workspace_id = 'users_workspace_from_jwt'`. This prevents horizontal privilege escalation.

## 6. Workload Logs

- **Source**: All pods running within user namespaces.
- **Collection**: Promtail, running as a DaemonSet, will scrape logs from all user pods.
- **Access Control and Visibility**:
  - Users can access logs for pods within projects they have permission to view.
- **Security Implementation**:
  - The HKS API will provide an endpoint like `GET /api/v1/.../projects/{projectId}/pods/{podName}/logs`.
  - Before proxying the log request to Loki, the API handler **must** perform a `SubjectAccessReview` against the project's vCluster Kubernetes API.
  - The review will check if the requesting user has `get` and `logs` permissions on the `pods` resource for the specified pod name.
  - The log stream is only returned if the access review succeeds. This leverages Kubernetes' own RBAC as the source of truth for access control.

## 7. Relationship with AIOps Tracing (Langfuse)

It is important to distinguish Audit Logs from the AIOps tracing system (Langfuse).

- **Langfuse**: A specialized tool for **developers** to debug the AI's internal reasoning.
- **ClickHouse (Audit Logs)**: A system of record for **users and admins** to see the final, executed actions.

This separation ensures developers have detailed traces while users have a clean, compliant audit trail.
